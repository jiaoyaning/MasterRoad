[TOC]

# 〇、`wait` / `notify` / `notifyAll`
[参考](https://www.cnblogs.com/joy99/p/10618910.html)
`wait`：线程自动释放其占有的对象锁，并等待notify
`notify`：唤醒一个正在wait当前对象锁的线程，并让它拿到对象锁
`notifyAll`：唤醒所有正在wait前对象锁的线程

`notify`和`notifyAll`的最主要的区别是：`notify`只是唤醒一个正在`wait`当前对象锁的线程，而`notifyAll`唤醒所有。值得注意的是：`notify`是本地方法，具体唤醒哪一个线程由虚拟机控制；`notifyAll`后并不是所有的线程都能马上往下执行，它们只是跳出了`wait`状态，接下来它们还会是竞 争对象锁。

---

**问：`sleep` 和 `wait` 方法的区别？**
>1. `sleep` 是线程的方法， `wait / notify / notifyAll` 是 `Object` 类的方法；
>2. `sleep` 不会释放当前线程持有的锁，到时间后程序会继续执行，`wait` 会释放线程持有的锁并挂起，直到通过 `notify` 或者 `notifyAll` 重新获得锁。

---

# 一、Synchronized


# 二、Lock
**问题为什么会在有了`Synchronized`的情况下，还设计`Lock`？** 
>`Synchronized`缺少申请不到进一步资源就释放已有资源的能力(比如死锁)。
以及其缺少如下能力。
>1. **能响应中断**   
   如果其他线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。  
   当A和B两个线程同时通过 `lock.lockInterruptibly()` 想获取某个锁时，假若此时线程A获取到了锁，
   而线程B只有等待，那么对线程B调用 `threadB.interrupt()` 方法能够中断线程B的等待过程。  
   注意是：中断是等待的那个线程B，而不是正在执行的线程A。  
>2. **非阻塞式的获取锁**
   `boolean b = lock.tryLock()` 尝试进行获取锁，如果获取不到并不会阻塞，而是直接返回。
>3. **超时控制**
   `boolean b = lock.tryLock(long time, timeUnit)` 在给定的时间限制内，如果没有获取到锁，不是进入阻塞状态，而是同样直接返回。

---

## Lock使用范式
```java
    Lock lock = new ReentrantLock();
    lock.lock();

    try{
        ...
    } finally {
        lock.unlock();
    }
```
**问: 为什么在`try{}`外面获取锁，却在`finally`中释放锁?**
  >在 finally 释放锁，是为了保证在获取到锁之后，最终能被释放。    
  > 
  >在 try{} 外获取锁主要考虑两个方面:   
  >1. 如果在还没有获取到锁时抛出了异常，那么释放锁会有问题，未曾拥有锁谈何释放。
  >2. 如果在获取锁时抛出了异常，也就是当前线程并未获取到锁，但执行到 finally 代码时，如果恰巧别的线程获取到了锁，则会被释放掉（无故释放）。

---

**问题： `Lock`是怎样起到锁的作用呢？**
`synchronized`在编译成`CPU`指令后，会有`moniterenter`和`moniterexit`指令的出现。
- `lock.lock()`  获取锁，“等同于” `synchronized` 的 `moniterenter`指令
- `lock.unlock()` 释放锁，“等同于” `synchronized` 的 `moniterexit` 指令

`Lock` 是怎么做到的呢？
>其实很简单，比如在`ReentrantLock`内部维护了一个 `volatile` 修饰的变量 `state`，通过 **`CAS`** 来进行读写（最底层还是交给硬件来保证原子性和可见性），如果 **`CAS`** 更改成功，即获取到锁，线程进入到 `try`代码块继续执行；如果没有更改成功，线程会被【挂起】，不会向下执行。

---

**问: 什么是公平锁和非公平锁？**
> 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
>* 优点：所有的线程都能得到资源，不会饿死在队列中。  
>* 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。  

>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
>* 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
>* 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

---

**问: ReentrantLock 是如何实现公平锁和非公平锁的？**
> 公平锁就是判断同步队列是否还有先驱节点的存在，只有没有先驱节点才能获取锁；而非公平锁是不管这个事的，能获取到同步状态就可以

## ReentrantLock

## ReentrantReadWriteLock
[参考](https://www.cnblogs.com/zaizhoumo/p/7782941.html)
`ReentrantReadWriteLock`是`Lock`的另一种实现方式，我们已经知道了`ReentrantLock`是一个`排他锁`或者`独占锁`，同一时间只允许一个线程访问，而`ReentrantReadWriteLock`允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。

相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时`ReentrantReadWriteLock`能够提供比排他锁更好的并发性和吞吐量。

读写锁内部维护了两个锁`readerLock`和`writerLock`，一个用于读操作，一个用于写操作。所有`ReadWriteLock`实现都必须保证 `writeLock`操作的内存同步效果也要保持与相关`readLock`的联系。也就是说，成功获取读锁的线程会看到写入锁之前版本所做的所有更新。

1. 公平性：读写锁支持非公平和公平的锁获取方式，非公平锁的吞吐量优于公平锁的吞吐量，默认构造的是非公平锁

2. 可重入：在线程获取读锁之后能够再次获取读锁，但是不能获取写锁，而线程在获取写锁之后能够再次获取写锁，同时也能获取读锁

3. 锁降级：线程获取写锁之后获取读锁，再释放写锁，这样实现了写锁变为读锁，也叫锁降级



# 三、AQS(AbstractQueuedSynchronizer)队列同步器
>两个队列：同步队列(双向链表)，等待队列(单链表)

锁获取的核心，实际上是在try方法中定义的，在节点从阻塞中醒来时，都会用try方法来获取锁，而公平与否在try方法中体现，即在公平锁中，try获取的前提时需要没有存在前驱节点的，而非公平锁就没有这个限制  

但是！同步队列不是FIFO(先进先出)的吗，它们入队排好顺序并且按照顺序一个一个的醒来，只有醒来的才有机会去获取锁，才能去执行try方法，这不还是公平的吗？

解答

线程在do方法中获取锁时，会先加入同步队列，之后根据情况再陷入阻塞。当阻塞后的节点一段时间后醒来时，这时候来了新的更多的线程来抢锁，这些新线程还没有加入到同步队列中去，也就是在try方法中获取锁。
在公平锁下，这些新线程会发现同步队列中存在节点等待，那么这些新线程将无法获取到锁，乖乖去排队；
而在非公平锁下，这些新线程会跟排队苏醒的线程进行锁争抢，失败的去同步队列中排队。
因此这里的公平与否，针对的其实是苏醒线程与还未加入同步队列的线程
而对于已经在同步队列中阻塞的线程而言，它们内部自身其实是公平的，因为它们是按顺序被唤醒的，这是根据AQS节点唤醒机制和同步队列的FIFO特性决定的

AQS 内部维护了一个 同步队列 (双向链表)，用于管理同步状态。
当线程获取同步状态失败时，就会将当前线程以及等待状态等信息构造成一个 Node 节点，将其加入到同步队列中尾部，阻塞该线程
当同步状态被释放时，会唤醒同步队列中“首节点”的线程获取同步状态

为什么要是双向同步队列？
1. 入队的时候方便找到最后一个节点。
2. 在队列同步器中，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态后，将会唤醒其他后续节点，
    后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点，如果是则尝试获取同步状态。
    所以为了能让后继节点获取到其前驱节点，同步队列便设置为双向链表，而等待队列没有这样的需求，就为单链表。

---

**问题：乐观锁与悲观锁？**
[参考](https://www.cnblogs.com/qjjazry/p/6581568.html)
1. **悲观锁**
   总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。
   传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。
   `再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。`
1. **乐观锁**
   顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。
   乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。
   `在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。`

---

**问题：什么是可重入锁？**
[参考](https://www.cnblogs.com/theRhyme/p/9133804.html)
指的是以线程为单位，当一个线程获取对象锁之后，这个线程可以再次获取本对象上的锁，而其他的线程是不可以的。

`synchronized 和   ReentrantLock 都是可重入锁。`

可重入锁的意义之一在于防止死锁。

实现原理实现是通过为每个锁关联一个请求计数器和一个占有它的线程。当计数为0时，认为锁是未被占有的；线程请求一个未被占有的锁时，JVM将记录锁的占有者，并且将请求计数器置为1 。

如果同一个线程再次请求这个锁，计数器将递增；
每次占用线程退出同步块，计数器值将递减。直到计数器为0,锁被释放。

---

**问题：一个线程执行synchronized同步代码时，再次重入该锁过程中，如果抛出异常，会释放锁吗？**
[参考](https://www.cnblogs.com/theRhyme/p/10078402.html)
如果锁的计数器为2，执行过程中抛出异常，锁的计数器直接置为0，会直接释放锁！

一个线程如果在执行同步代码块过程中抛出异常未捕获，会立即终止，退出同步代码块，并且释放锁，不会执行后续代码。

最核心的就是抛了异常，线程内部如果没处理，线程会直接停止！




