[TOC]
# 乐观锁与悲观锁
[参考](https://www.cnblogs.com/qjjazry/p/6581568.html)
## 1. 悲观锁
总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。传统的关系型数据库里边就用到了很多这种锁机制，比如行锁，表锁等，读锁，写锁等，都是在做操作之前先上锁。`再比如Java里面的同步原语synchronized关键字的实现也是悲观锁。`
## 2. 乐观锁
顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，像数据库提供的类似于write_condition机制，其实都是提供的乐观锁。`在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS实现的。`



# 一、Synchronized

# 二、Lock
**为什么会在有了`Synchronized`的情况下，还设计`Lock`？** 
>`Synchronized`缺少申请不到进一步资源就释放已有资源的能力(比如死锁)。
以及其缺少如下能力。
>1. **能响应中断**   
   如果其他线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。  
   当A和B两个线程同时通过 `lock.lockInterruptibly()` 想获取某个锁时，假若此时线程A获取到了锁，
   而线程B只有等待，那么对线程B调用 `threadB.interrupt()` 方法能够中断线程B的等待过程。  
   注意是：中断是等待的那个线程B，而不是正在执行的线程A。  

>2. **非阻塞式的获取锁**
   `boolean b = lock.tryLock()` 尝试进行获取锁，如果获取不到并不会阻塞，而是直接返回。

>3. **超时控制**
   `boolean b = lock.tryLock(long time, timeUnit)` 在给定的时间限制内，如果没有获取到锁，不是进入阻塞状态，而是同样直接返回。

## `Lock`使用范式
```
    Lock lock = new ReentrantLock();
    lock.lock();

    try{
        ...
    } finally {
        lock.unlock();
    }
```
**问: 为什么在`try{}`外面获取锁，却在`finally`中释放锁?**
  >在 finally 释放锁，是为了保证在获取到锁之后，最终能被释放。    
  > 
  >在 try{} 外获取锁主要考虑两个方面:   
  >1. 如果在还没有获取到锁时抛出了异常，那么释放锁会有问题，未曾拥有锁谈何释放。
  >2. 如果在获取锁时抛出了异常，也就是当前线程并未获取到锁，但执行到 finally 代码时，如果恰巧别的线程获取到了锁，则会被释放掉（无故释放）。

## `Lock`是怎样起到锁的作用呢？
`synchronized`在编译成`CPU`指令后，会有`moniterenter`和`moniterexit`指令的出现。
- `lock.lock()`  获取锁，“等同于” `synchronized` 的 `moniterenter`指令
- `lock.unlock()` 释放锁，“等同于” `synchronized` 的 `moniterexit` 指令

`Lock` 是怎么做到的呢？
>其实很简单，比如在`ReentrantLock`内部维护了一个 `volatile` 修饰的变量 `state`，通过 **`CAS`** 来进行读写（最底层还是交给硬件来保证原子性和可见性），如果 **`CAS`** 更改成功，即获取到锁，线程进入到 `try`代码块继续执行；如果没有更改成功，线程会被【挂起】，不会向下执行。

**问: 什么是公平锁和非公平锁？**
> 公平锁：多个线程按照申请锁的顺序去获得锁，线程会直接进入队列去排队，永远都是队列的第一位才能得到锁。
>* 优点：所有的线程都能得到资源，不会饿死在队列中。  
>* 缺点：吞吐量会下降很多，队列里面除了第一个线程，其他的线程都会阻塞，cpu唤醒阻塞线程的开销会很大。  

>非公平锁：多个线程去获取锁的时候，会直接去尝试获取，获取不到，再去进入等待队列，如果能获取到，就直接获取到锁。
>* 优点：可以减少CPU唤醒线程的开销，整体的吞吐效率会高点，CPU也不必取唤醒所有线程，会减少唤起线程的数量。
>* 缺点：你们可能也发现了，这样可能导致队列中间的线程一直获取不到锁或者长时间获取不到锁，导致饿死。

**问: ReentrantLock 是如何实现公平锁和非公平锁的？**
> 公平锁就是判断同步队列是否还有先驱节点的存在，只有没有先驱节点才能获取锁；而非公平锁是不管这个事的，能获取到同步状态就可以

## ReentrantLock

# 三、AQS(AbstractQueuedSynchronizer)
>两个队列：同步队列(双向链表)，等待队列(单链表)

锁获取的核心，实际上是在try方法中定义的，在节点从阻塞中醒来时，都会用try方法来获取锁，而公平与否在try方法中体现，即在公平锁中，try获取的前提时需要没有存在前驱节点的，而非公平锁就没有这个限制  

但是！同步队列不是FIFO(先进先出)的吗，它们入队排好顺序并且按照顺序一个一个的醒来，只有醒来的才有机会去获取锁，才能去执行try方法，这不还是公平的吗？

解答

线程在do方法中获取锁时，会先加入同步队列，之后根据情况再陷入阻塞。当阻塞后的节点一段时间后醒来时，这时候来了新的更多的线程来抢锁，这些新线程还没有加入到同步队列中去，也就是在try方法中获取锁。
在公平锁下，这些新线程会发现同步队列中存在节点等待，那么这些新线程将无法获取到锁，乖乖去排队；
而在非公平锁下，这些新线程会跟排队苏醒的线程进行锁争抢，失败的去同步队列中排队。
因此这里的公平与否，针对的其实是苏醒线程与还未加入同步队列的线程
而对于已经在同步队列中阻塞的线程而言，它们内部自身其实是公平的，因为它们是按顺序被唤醒的，这是根据AQS节点唤醒机制和同步队列的FIFO特性决定的

AQS 内部维护了一个 同步队列 (双向链表)，用于管理同步状态。
当线程获取同步状态失败时，就会将当前线程以及等待状态等信息构造成一个 Node 节点，将其加入到同步队列中尾部，阻塞该线程
当同步状态被释放时，会唤醒同步队列中“首节点”的线程获取同步状态

为什么要是双向同步队列？
1. 入队的时候方便找到最后一个节点。
2. 在队列同步器中，头节点是成功获取到同步状态的节点，而头节点的线程释放了同步状态后，将会唤醒其他后续节点，
    后继节点的线程被唤醒后需要检查自己的前驱节点是否是头节点，如果是则尝试获取同步状态。
    所以为了能让后继节点获取到其前驱节点，同步队列便设置为双向链表，而等待队列没有这样的需求，就为单链表。







