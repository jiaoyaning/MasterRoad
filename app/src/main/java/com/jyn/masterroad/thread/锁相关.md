# 一、Synchronized

# 二、Lock
## 为什么会在有了`Synchronized`的情况下，还设计`Lock`？
`Synchronized`缺少申请不到进一步资源就释放已有资源的能力(比如死锁)。
以及其缺少如下能力。
1. **能响应中断**   
   如果其他线程正在等待获取锁，则这个线程能够响应中断，即中断线程的等待状态。  
   当A和B两个线程同时通过 `lock.lockInterruptibly()` 想获取某个锁时，假若此时线程A获取到了锁，
   而线程B只有等待，那么对线程B调用 `threadB.interrupt()` 方法能够中断线程B的等待过程。  
   注意是：中断是等待的那个线程B，而不是正在执行的线程A。  

2. **非阻塞式的获取锁**
   `boolean b = lock.tryLock()` 尝试进行获取锁，如果获取不到并不会阻塞，而是直接返回。

3. **超时控制**
   `boolean b = lock.tryLock(long time, timeUnit)` 在给定的时间限制内，如果没有获取到锁，不是进入阻塞状态，而是同样直接返回。

## `Lock`使用范式
```
    Lock lock = new ReentrantLock();
    lock.lock();

    try{
        ...
    } finally {
        lock.unlock();
    }
```
**问: 为什么在`try{}`外面获取锁，却在`finally`中释放锁?**
  >在 finally 释放锁，是为了保证在获取到锁之后，最终能被释放。    
  > 
  >在 try{} 外获取锁主要考虑两个方面:   
  >1. 如果在还没有获取到锁时抛出了异常，那么释放锁会有问题，未曾拥有锁谈何释放。
  >2. 如果在获取锁时抛出了异常，也就是当前线程并未获取到锁，但执行到 finally 代码时，如果恰巧别的线程获取到了锁，则会被释放掉（无故释放）。

## `Lock`是怎样起到锁的作用呢？
`synchronized`在编译成`CPU`指令后，会有`moniterenter`和`moniterexit`指令的出现。
- `lock.lock()`  获取锁，“等同于” `synchronized` 的 `moniterenter`指令
- `lock.unlock()` 释放锁，“等同于” `synchronized` 的 `moniterexit` 指令

`Lock` 是怎么做到的呢？
>其实很简单，比如在`ReentrantLock`内部维护了一个 `volatile` 修饰的变量 `state`，通过 **`CAS`** 来进行读写（最底层还是交给硬件来保证原子性和可见性），如果 **`CAS`** 更改成功，即获取到锁，线程进入到 `try`代码块继续执行；如果没有更改成功，线程会被【挂起】，不会向下执行。

**问: ReentrantLock 是如何实现公平锁和非公平锁的？**
> 公平锁就是判断同步队列是否还有先驱节点的存在，只有没有先驱节点才能获取锁；而非公平锁是不管这个事的，能获取到同步状态就可以


# 三、AQS
> AbstractQueuedSynchronizer













