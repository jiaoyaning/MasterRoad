[TOC] 

# 一、Activity
>Activity是什么时候塞入布局并绘制的，一切都要从`setContentView`开始

第一步：`activity`绑定`xml`
```java
override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    setContentView(R.layout.activity_layout) //activity绑定xml
}
```
第二步：`activity`中的`window`添加`xml`
```java
//Activity类中方法
private Window mWindow;

public void setContentView(@LayoutRes int layoutResID) {
    getWindow().setContentView(layoutResID);
    ...
}

public Window getWindow() {
    return mWindow;
}
```
问题：`window`是什么？和`activity`是什么关系？
>`setContentView()`本质上是把xml布局设置在了`window`上面，所以`window`才是真正存储并显示布局的窗口，

# 二、Window 和 PhoneWindow 和 DecorView
> 找出window是什么，以及和activity有什么关联

第一步：`Activity`中的`Window`变量在`attach()`方法中被实例化成`PhoneWindow`对象。
```java
//Activity类中方法
final void attach(... , ...){
    ...
    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    ...
}
```

问题：`Activty`的`attach()`方法是什么时候被调用的?
> 答：在`ActivityThread`中`Activity`自身被反射实例化后，随即调用其`attach()`方法，其成员变量`Window`此时被实例化为`PhoneWindow`对象。
```java
//ActivityThread类中方法
private Activity performLaunchActivity(... , ...) {
    Activity activity = null;
    //反射创建Activity对象
    activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);
    ...
    //调用Activity的attach方法
    activity.attach(...)
    ...
    //回调Activity的 onCreate() 方法
    mInstrumentation.callActivityOnCreate(activity, r.state);
    ...
}
```
第二步：从`Activity`的`setContentView()`到`PhoneWindow`的`setContentView()`
```java
//PhoneWindow类中方法
public void setContentView(int layoutResID) {
    if (mContentParent == null) { 
        installDecor(); //此处代码下面再看
    }
    ...
    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { 
        //此处为动画处理，略过(结果其实一样)
        ...
    } else {
        //把xml布局添加到mContentParent中
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    ...
}
```
问题：`mContentParent`是什么？为什么要把xml布局文件添加到它里面。
>答：`mContentParent`是`screen_simple.xml`中id为`@android:id/content` 的`FrameLayout`view，我们的xml布局就是添加到了该`FrameLayout`中。
```java
//PhoneWindow类中方法
private void installDecor() { //此方法上面有看到
    ...
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);//此处mDecor下面会分析到
    }
    ...
}

public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;

protected ViewGroup generateLayout(DecorView decor) {
    ...
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
```
问题：`generateLayout()`中的`findViewById()`中的`R.id.content`是谁，以及是从哪个布局文件中找的？
>此处的`findViewById`找寻的`DecorView`中id为`R.id.content`的子view，而`DecorView`是一个名为`screen_simple.xml`的布局文件。
```java
//Window类中方法
public <T extends View> T findViewById(@IdRes int id) {
    return getDecorView().findViewById(id);
}

public abstract @NonNull View getDecorView();
```
```java
//PhoneWindow类中getDecorView()方法的实现
public final @NonNull View getDecorView() {
    if (mDecor == null || mForceDecorInstall) {
        installDecor();//此处再次出现
    }
    return mDecor;
}
```
问题：`mDecor`是谁，它的子`view` `mContentParent`为什么可以添加我们在Activity中设置的xml布局
>答 `mDecor`是`window`类中用来展示的整体页面的view，而`mContentParent`是其一个子View，用来放置`Activity` `setContentView`方法所设置的XML布局。
```java
//PhoneWindow类中方法
private void installDecor() { //此方法上面有看到
    ...
    if (mDecor == null) {
        //初始化mDecor
         mDecor = generateDecor(-1); 
         ...
    }
    ...

    if (mContentParent == null) {
        //再根据mDecor初始化mContentParent
        mContentParent = generateLayout(mDecor); 
    }
    ...
}

protected DecorView generateDecor(int featureId) {
    ...
    return new DecorView(... , ...);
}

protected ViewGroup generateLayout(DecorView decor) {
    ...
    int layoutResource;
    if (...){ ...
    }else{
        layoutResource = R.layout.screen_simple;
    }
    //把布局文件 R.layout.screen_simple 添加的 DecorView 中
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);

    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
```

```java
//DecorView方法
void onResourcesLoaded(LayoutInflater inflater, int layoutResource){
    ...
    final View root = inflater.inflate(layoutResource, null)
    if(...){
        ...
    }else{
        addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    }
    ...
}
```

```xml
<!-- screen_simple.xml -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true"
    android:orientation="vertical">
    <ViewStub android:id="@+id/action_mode_bar_stub"
              android:inflatedId="@+id/action_mode_bar"
              android:layout="@layout/action_mode_bar"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:theme="?attr/actionBarTheme" />
    <FrameLayout
         android:id="@android:id/content"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
         android:foregroundInsidePadding="false"
         android:foregroundGravity="fill_horizontal|top"
         android:foreground="?android:attr/windowContentOverlay" />
</LinearLayout>
```
问题：`DecorView`是如何添加到`window`上面的？
详细点说我们上面所看到的逻辑只追踪到了`new DecorView(... , ...)`，但是一个被`new`出来的`view`是如何通过`window`展示到屏幕前的呢?
**注意：此前所以的分析都还都只停留在`onCreate()`方法阶段，而接下来就到了`onResume()`的表演时间。**

```java 
//ActivityThread类中方法
public void handleResumeActivity(... , ...){
    ...
    //分发并回调Activity到的onResume()方法
    final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason); 
    ...
    final Activity a = r.activity;
    ...
    //获得当前Activity的PhoneWindow对象
    r.window = r.activity.getWindow(); 
    //获得当前phoneWindow的DecorView对象
    View decor = r.window.getDecorView();
    decor.setVisibility(View.INVISIBLE);
    //获取当前Activity的WindowManager 注意：画重点
    ViewManager wm = a.getWindowManager();
    WindowManager.LayoutParams l = r.window.getAttributes();
    a.mDecor = decor;
    ...
    wm.addView(decor, l); //通过Activity的WindowManager添加DecorView
    ...
}
```
```java
//Activity类中方法
private WindowManager mWindowManager;

public WindowManager getWindowManager() {
    return mWindowManager;
}

final void attach(... , ...){
    ...
    mWindow = new PhoneWindow(this, window, activityConfigCallback);
    ...
    mWindow.setWindowManager(
            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
            ...);
    ...
    mWindowManager = mWindow.getWindowManager();
    ...
}
```
```java
//Window中的方法

public void setWindowManager(WindowManager wm, ...) {
    if (wm == null) {
        wm = (WindowManager)mContext.getSystemService(Context.WINDOW_SERVICE);
    }
    mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this);
}
```

问题：`mWindowManager`是什么？为什么它可以通过`addView(DecorView)`呢？这这个`addview()`又是做什么的呢？`addview()`完屏幕就显示出布局了么？
>`mWindowManager`是一个`WindowManagerImpl`的实例对象。
>`ActivityThread`类的`handleResumeActivity()`方法中所调用的`addView(DecorView)`其实是`WindowManagerImpl`中的`addView()`

# 三、WindowManagerImpl 和 WindowManagerGlobal
```Java
//WindowManagerImpl类

private final WindowManagerGlobal mGlobal = WindowManagerGlobal.getInstance();

//Window中的mWindowManager变量都是由该方法创建
public WindowManagerImpl createLocalWindowManager(Window parentWindow) {
    return new WindowManagerImpl(mContext, parentWindow);
}

public void addView(View view,ViewGroup.LayoutParams params) {
    ...
    mGlobal.addView(view, params, ...);
}
```
问题：`WindowManagerGlobal`又是什么？这个`addView(DecorView)`这个方法经过层层传递，最终传到了这个单例类，那它是如何实现绘制页面的呢？
>答：`WindowManagerGlobal`是个全局单例，也就是说无论`activity`有多少个，`activity`中的`mWindowManager`实例化了多少个，把`DecorView`添加到`Window`上的方法始终都指向了同一个方法 `WindowManagerGlobal`的`addView()`。
```java
//WindowManagerGlobal 类
private final ArrayList<View> mViews = new ArrayList<View>();
private final ArrayList<ViewRootImpl> mRoots = new ArrayList<ViewRootImpl>();

public void addView(View view, ViewGroup.LayoutParams params, ...) {
    ...
    ViewRootImpl root;
    root = new ViewRootImpl(view.getContext(), display);
    ...
    mViews.add(view); //暂且不表
    mRoots.add(root); //暂且不表
    ...
    root.setView(view, wparams, panelParentView);
}

```
问题：`ViewRootImpl`是什么？为什么每次`addView()`的时候都会实例化一个？我们的`DecorView`最终是被设置给了它。难道说是这个`ViewRootImpl`控制的`DecorView`最终显示在了屏幕之上?
>进入第四章`ViewRootImpl`

# 四、ViewRootImpl


