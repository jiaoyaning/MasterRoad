[TOC] 

# 一、Activity
>Activity是什么时候塞入布局并绘制的，一切都要从`setContentView`开始

第一步：`activity`绑定`xml`
```java
  override fun onCreate(savedInstanceState: Bundle?) {
      super.onCreate(savedInstanceState)
      setContentView(R.layout.activity_layout) //activity绑定xml
  }
```
第二步：`activity`中的`window`添加`xml`
```java
 //Activity类中方法

  private Window mWindow;

  public void setContentView(@LayoutRes int layoutResID) {
      getWindow().setContentView(layoutResID);
      ...
  }

  public Window getWindow() {
      return mWindow;
  }
```
问题：`window`是什么？和`activity`是什么关系？
>`window`才是真正存储并显示布局的窗口，

# 二、Window 和 PhoneWindow
> 找出window是什么，以及和activity有什么关联

第一步：`Activity`中的`Window`变量在`attach()`方法中被实例化成`PhoneWindow`对象。
```java
  final void attach(... , ...){
      ...
      mWindow = new PhoneWindow(this, window, activityConfigCallback);
      ...
  }
```

问题：`Activty`的`attach()`方法是什么时候被调用的?
> 答：在`ActivityThread`中`Activity`自身被反射实例化后，随即调用其`attach()`方法，其成员变量`Window`此时被实例化为`PhoneWindow`对象。
```java
//ActivityThread类中方法
private Activity performLaunchActivity(... , ...) {
    Activity activity = null;
    try{
        //反射创建Activity对象并调用其attach方法
        java.lang.ClassLoader cl = appContext.getClassLoader();
        activity = mInstrumentation.newActivity(cl, component.getClassName(), r.intent);
        ...
    }catch(Exception e){
        ...
    }
    ...
    activity.attach(...)
    ...

    //此次用于回调Activity的 onCreate() 方法
    if (r.isPersistable()) {
        mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
    } else {
        mInstrumentation.callActivityOnCreate(activity, r.state);
    }
    ...
}
```
第二步：从`Activity`的`setContentView()`到`PhoneWindow`的`setContentView()`
```java
//PhoneWindow类中方法
public void setContentView(int layoutResID) {
    if (mContentParent == null) { 
        installDecor(); //此处代码下面再看
    } else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) {
        mContentParent.removeAllViews();
    }

    ...

    if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) { 
        //此处为动画处理，略过(结果其实一样)
        ...
    } else {
        //把xml布局添加到mContentParent中
        mLayoutInflater.inflate(layoutResID, mContentParent);
    }
    ...
}
```
问题：`mContentParent`是什么？为什么要把xml布局文件添加到它里面。
>答：`mContentParent`是`screen_simple.xml`中id为`@android:id/content` 的`FrameLayout`view，我们的xml布局就是添加到了该`FrameLayout`中。
```java
//PhoneWindow类中方法
private void installDecor() { //此方法上面有看到
    ...
    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor);//此处mDecor下面会分析到
    }
    ...
}

public static final int ID_ANDROID_CONTENT = com.android.internal.R.id.content;

protected ViewGroup generateLayout(DecorView decor) {
    ...
    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
```
问题：`generateLayout()`中的`findViewById()`中的`R.id.content`是谁，以及是从哪个布局文件中找的？
>此处的`findViewById`找寻的`DecorView`中id为`R.id.content`的子view，而`DecorView`是一个名为`screen_simple.xml`的布局文件。
```java
//Window类中方法
public <T extends View> T findViewById(@IdRes int id) {
    return getDecorView().findViewById(id);
}

public abstract @NonNull View getDecorView();
```
```java
//PhoneWindow类中getDecorView()方法的实现
public final @NonNull View getDecorView() {
    if (mDecor == null || mForceDecorInstall) {
        installDecor();//此处再次出现
    }
    return mDecor;
}
```
问题：`mDecor`是谁，它的子`view` `mContentParent`为什么可以添加我们在Activity中设置的xml布局
>答 `mDecor`是`window`类中用来展示的整体页面的view，而`mContentParent`是其一个子View，用来放置`Activity` `setContentView`方法所设置的XML布局。
```java
//PhoneWindow类中方法
private void installDecor() { //此方法上面有看到
    ...
    if (mDecor == null) {
         mDecor = generateDecor(-1); //初始化mDecor
         ...
    }
    ...

    if (mContentParent == null) {
        mContentParent = generateLayout(mDecor); //再根据mDecor初始化mContentParent
    }

    ...
}

protected DecorView generateDecor(int featureId) {
    ...
    return new DecorView(... , ...);
}

protected ViewGroup generateLayout(DecorView decor) {
    ...
    int layoutResource;
    if (...){
        ...
    }else{
        layoutResource = R.layout.screen_simple;
    }
    
    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);

    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);
    ...
    return contentParent;
}
```

```java
//DecorView方法
void onResourcesLoaded(LayoutInflater inflater, int layoutResource){
    ...
    final View root = inflater.inflate(layoutResource, null)
    if(...){
        ...
    }else{
        addView(root, 0, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));
    }
    ...
}
```

```xml
<!-- screen_simple.xml -->
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:fitsSystemWindows="true"
    android:orientation="vertical">
    <ViewStub android:id="@+id/action_mode_bar_stub"
              android:inflatedId="@+id/action_mode_bar"
              android:layout="@layout/action_mode_bar"
              android:layout_width="match_parent"
              android:layout_height="wrap_content"
              android:theme="?attr/actionBarTheme" />
    <FrameLayout
         android:id="@android:id/content"
         android:layout_width="match_parent"
         android:layout_height="match_parent"
         android:foregroundInsidePadding="false"
         android:foregroundGravity="fill_horizontal|top"
         android:foreground="?android:attr/windowContentOverlay" />
</LinearLayout>
```
问题：`DecorView`是如何添加到`window`上面的？
详细点说我们上面所看到的逻辑只追踪到了`new DecorView(... , ...)`，但是一个被`new`出来的`view`是如何通过`window`展示到屏幕前的呢?
**注意：此前所以的分析都还都只停留在`onCreate()`方法阶段，而接下来就到了`onResume`的表演时间。**

```java 
//ActivityThread类中方法
public void handleResumeActivity(... , ...){
    ...
    r.window = r.activity.getWindow();
    View decor = r.window.getDecorView();
    decor.setVisibility(View.INVISIBLE);
    ViewManager wm = a.getWindowManager();
    WindowManager.LayoutParams l = r.window.getAttributes();
    a.mDecor = decor;
    wm.addView(decor, l);
    ...
}

```

