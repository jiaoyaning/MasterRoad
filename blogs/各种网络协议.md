[TOC]

# TCP & UDP

#### **五层网络体系是什么？**
> 5. 应用层
> 4. 传输层
> 3. 网络层
> 2. 数据链路层
> 1. 物理层

---
#### **问题：一个TCP & UDP包的大小？**
> **MTU：** 泛指通讯协议中的最大传输单元。一般用来说明TCP/IP四层协议中数据链路层的最大传输单元，不同类型的网络MTU也会不同，我们普遍使用的以太网的MTU是1500，即最大只能传输1500字节的数据帧。
>
> **UDP：** 包的大小为 1500(MTU) - IP头(20) - UDP头(8) = 1472(Bytes)
> **TCP：** 包的大小为 1500(MTU) - IP头(20) - TCP头(20) = 1460 (Bytes)

---

#### **问题：半和粘包？如何解决粘包问题？**
[参考](https://github.com/balloonwj/CppGuide/blob/master/articles/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/TCP%E5%8D%8F%E8%AE%AE%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E7%B2%98%E5%8C%85%E3%80%81%E5%8D%8A%E5%8C%85%E9%97%AE%E9%A2%98.md)
> TCP 协议是流式协议，即协议的内容是像流水一样的字节流，内容与内容之间没有明确的分界标志，需要我们人为地去给这些协议划分边界。
>
> 注意：TCP 协议，在大多数场景下，是不存在丢包和包乱序问题的，TCP 通信是可靠通信方式，TCP 协议栈通过序列号和包重传确认机制保证数据包的有序和一定被正确发到目的地；如果是 UDP 协议，如果不能接受少量丢包，那就要自己在 UDP 的基础上实现类似 TCP 这种有序和可靠传输机制了（例如 RTP协议、RUDP 协议）。
>
> 先来解释一下什么是**粘包**？所谓粘包就是连续给对端发送两个或者两个以上的数据包，对端在一次收取中可能收到的数据包大于 1 个，大于 1 个，可能是几个（包括一个）包加上某个包的部分，或者干脆就是几个完整的包在一起。 当然，也可能收到的数据只是一个包的部分，这种情况一般也叫**半包**。
>
> 解决方案：想办法从收到的数据中把包与包的边界给区分出来。
> 1. 固定包长的数据包
     > 即每个协议包的长度都是固定的
> 2. 以指定字符（串）为包的结束标志
     > 这种协议包比较常见，即字节流中遇到特殊的符号值时就认为到一个包的末尾了。例如，我们熟悉的 FTP协议，发邮件的 SMTP 协议，一个命令或者一段数据后面加上"\r\n"（即所谓的 CRLF）表示一个包的结束。对端收到后，每遇到一个”\r\n“就把之前的数据当做一个数据包。
> 3. 包头 + 包体格式
     > 这种格式的包一般分为两部分，即包头和包体，包头是固定大小的，且包头中必须含有一个字段来说明接下来的包体有多大。
---

# HTTP & HTTPS

#### **问题：HTTPS证书怎么工作的？**
> 1. **申请证书：** 即需要被验证身份的一端，需要申请一份能够验证自己身份的证书
    > 用户向 CA 机构提交自己的信息（如域名）和公钥，由CA机构私钥加密后生成证书，交于服务器。
> 2. **验证证书：** 即需要验证对方身份的一端，拿到证书后验证对端的身份
    > 系统内置CA机构公钥，可以验证证书的合法性，并得到服务端公钥。

---

#### **问题：GET 和 POST 区别？**
> 1.  GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。 
> 2.  GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。而 POST 数据不会显示在 URL 中。是放在 Request body 中。 
> 3.  对参数的数据类型，GET 只接受 ASCII 字符，而 POST 没有限制。 
> 4.  GET 请求参数会被完整保留在浏览器历史记录里；相反，POST 请求参数也不会被浏览器保留。 
> 5.  GET 请求只能进行 url 编码（ application/x-www-form-urlencoded），而 POST 支持多种编码方式。 
> 6.  GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。 
> 7.  GET 在浏览器回退时是无害的，而 POST 会再次提交请求。 

---

#### **问题：Get、Post 请求发送的数据包区别？**
> 有理论说 GET 请求时产生一个TCP 数据包；POST 请求时产生两个TCP 数据包。
> > 1. GET：浏览器会把 http header 和 data 一并发送出去，服务器响应 200（返回数据； 
> > 2. POST：浏览器先发送 header，服务器响应 100 continue，浏览器再发送 data，服务器响应 200 OK（返回数据）。 
> 
> 看起来POST理论上时间上消耗的要多一点，GET更有效率，但并不是。
> > 1. GET 与 POST 都有自己的语义，不能随便混用。
> > 2. 在网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的 TCP 在验证数据包完整性上，有非常大的优点。 
> > 3. 并不是所有浏览器都会在 POST 中发送两次包，Firefox 就只发送一次。

---

#### **问题：GET 可以像 POST 那样设置 Request body 么？**
>GET 和 POST 在本质上没有区别，都是 HTTP 协议中的两种发送请求的方法
>HTTP 的底层是 TCP/IP。所以 GET 和 POST 的底层也是 TCP/IP，也就是说，GET/POST 都是 TCP 链接。
>GET 和 POST 能做的事情是一样一样的。你要给 GET 加上 request body，给 POST 带上 url 参数，技术上是完全行的通的。

---

#### **问题：长连接为何需要心跳？**
[博客](https://mp.weixin.qq.com/s?__biz=MzIxNTM3NDE2Nw==&mid=2247486859&idx=1&sn=2d6b9c00dd60714bd7a5be2015833b52&chksm=97980db3a0ef84a57197a5c564ba2298d2882fc28e8ee52e856766e0cd48a687536bf1a6cf96&scene=132#wechat_redirect)
> 有很多种理由，举几个例子。服务器上有很多长连接，但是有些长连接可以释放了，比如用户合上笔记本下班回家了，网页也不需要再看了。
> 如果服务器发心跳报文自然得不到回复，那么就可以将长连接占据的内存释放掉。 还有类似BGP这种长连接，发送/接收周期性的心跳，可以快速检测底层网络的连通性，
> 可以快速完成网络物理链路的切换，将流量切换到连通的物理链路，毕竟底层网络才是真正的连接，才是真正搬运流量的载体！


[一篇搞懂TCP、HTTP、Socket、Socket连接池](https://mp.weixin.qq.com/s/00wm0tzz8Q1kUIQSlLXnUA)
[经得住拷问的 HTTPS 原理解析](https://mp.weixin.qq.com/s/KcW89_ohdxE4lgmKbEYoHg)
[这样回答GET和POST原理，面试官请我喝咖啡了](https://mp.weixin.qq.com/s/q-0s5Czi8uxGm5Hka-wbNw)