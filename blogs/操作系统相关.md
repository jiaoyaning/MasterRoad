[TOC]

# 虚拟内存
[如何理解虚拟内存](https://zhuanlan.zhihu.com/p/96098896)

虚拟内存这个概念是后来才提出的，一开始并没有虚拟内存。
那个时候的计算机，程序指令所访问的内存地址就是物理内存地址. 也就是不得不把程序的全部装进内存当中，然后运行。
物理内存其实就是插在计算机主板内存槽上的实际物理内存，CPU可以直接进行寻址。
物理内存的容量是固定的，但是寻址空间却取决于cpu地址线条数，
如32位机，则寻址空间为2^32 = 4G，所以最大支只持4G的寻址空间，即使插了8G的内存条也只能使用4G内存。

在这种直接使用物理内存的状态下就会产生一些问题：

> 1. 内存空间利用率的问题
>> 各个进程对内存的使用会导致内存碎片化，当要用malloc分配一块很大的内存空间时，
>> 可能会出现虽然有足够多的空闲物理内存，却没有足够大的连续空闲内存这种情况，东一块西一块的内存碎片就被浪费掉了
>
> 2. 读写内存的安全性问题
>> 物理内存本身是不限制访问的，任何地址都可以读写，而现代操作系统需要实现不同的页面具有不同的访问权限，例如只读的数据等等
>
> 3. 进程间的安全问题
>> 各个进程之间没有独立的地址空间，一个进程由于执行错误指令或是恶意代码都可以直接修改其它进程的数据，
>> 甚至修改内核地址空间的数据，这是操作系统所不愿看到的
>
> 4. 内存读写的效率问题
>> 当多个进程同时运行，需要分配给进程的内存总和大于实际可用的物理内存时，需要将其他程序暂时拷贝到硬盘当中，
>> 然后将新的程序装入内存运行。由于大量的数据频繁装入装出，内存的使用效率会非常低

**所以什么是虚拟内存？**
> 每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，虚拟的意思就是，其实这个地址空间时不存在的，
仅仅是每个进程“认为”自己拥有4G的内存，而实际上，它用了多少空间，操作系统就在磁盘上划出多少空间给它，
等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行数据拷贝

**虚拟内存的工作原理**
> 当一个进程试图访问虚拟地址空间中的某个数据时，会经历下面两种情况的过程：
> 1. CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位，如果有效位为1，
     > 说明在页表条目中的物理内存地址不为空，根据物理内存地址，访问物理内存中的内容，返回
> 2. CPU想访问某个虚拟内存地址，找到进程对应的页表中的条目，判断有效位，如果有效位为0，
     > 但页表条目中还有地址，这个地址是磁盘空间的地址，这时触发缺页异常，
     > 系统把物理内存中的一些数据拷贝到磁盘上，腾出所需的空间，并且更新页表。此时重新执行访问之前虚拟内存的指令，就会发现变成了情况1.

# mmap 内存映射
[mmap](https://blog.csdn.net/edwardlulinux/article/details/8604400)
mmap的执行，仅仅是在内核中建立了文件与虚拟内存空间的对应关系。用户访问这些虚拟内存空间时，页面表里面是没有这些空间的表项的。
当用户程序试图访问这些映射的空间时，于是产生缺页异常。内核捕捉这些异常，逐渐将文件载入。
所谓的载入过程，具体的操作就是read和write在管理pagecache。Vma的结构体中有很文件操作集。
vma操作集中会有自己关于page cache的操作集合。这样，虽然是两种不同的系统调用，由于操作和调用触发的路径不同。
但是最后还是落实到了page cache的管理。实现了文件内容的操作。


