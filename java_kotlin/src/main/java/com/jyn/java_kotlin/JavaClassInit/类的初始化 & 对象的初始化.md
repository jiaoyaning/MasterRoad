# 类加载过程
 **加载** —> **验证** —> **准备** —> **解析** —> **初始化**  
 参考：https://mp.weixin.qq.com/s/764Tddh1j0wZ8nL3hsiyjQ
## 1. 加载
类加载过程的第一步，主要完成下面3件事情：
   * 通过全类名获取定义此类的二进制字节流
   * 将字节流所代表的静态存储结构转换为方法区的运行时数据结构
   * 在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口
    

## 2. 验证
## 3. 准备
准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些内存都将在方法区中分配。对于该阶段有以下几点需要注意：
   * 这时候进行内存分配的仅包括类变量（static），而不包括实例变量，实例变量会在对象实例化时随着对象一块分配在 Java 堆中。
   * 这里所设置的初始值"通常情况"下是数据类型默认的零值（如0、0L、null、false等），比如我们定义了`public static int value=111`，那么 value 变量在准备阶段的初始值就是 0 而不是111（初始化阶段才会复制）。特殊情况：比如给 value 变量加上了 fianl 关键字`public static final int value=111`，那么准备阶段 value 的值就被复制为 111。
  
## 4. 解析
解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。
解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用限定符7类符号引用进行。

## 5. 初始化
初始化是类加载的最后一步，也是真正执行类中定义的 Java 程序代码(字节码)，初始化阶段是执行类构造器 <clinit> ()方法的过程。


# 类的初始化
### 类的初始化触发机制
在同一个类加载器下，一个类只会被初始化一次，共有六种触发类初始化的时机  
1. 虚拟机启动时，包含main方法的主类  
2. new 指令创建对象时(目标类未被初始化时进行初始化)  
3. 当遇到访问静态方法或者静态字段的指令时，如果目标对象类没有被初始化则进行初始化操作（final修饰的静态除外）；  
4. 子类的初始化过程如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化；
5. 使用反射API 进行反射调用时，如果类没有进行过初始化则需要先触发其初始化；  
6. 第一次调用java.lang.invoke.MethodHandle 实例时，需要初始化 MethodHandle 指向方法所在的类。  

巧记：`main` `new` `静态` 加 `反射`，`父类` `Method Handle`。  
    闷牛静反父(李晨饰演的曹丕反抗父亲)

上述6种情况在JVM中被称为`主动引用`，除这六种之外的所有引用类的方式都被称为`被动引用`，被动引用并不会触发类的初始化。  
最典型的🌰是在子类中调用父类的静态变量。
对于静态字段，只有直接定义这个字段的类才会被初始化，因此通过子类 Child 来引用父类 Parent 中定义的静态字段，只会触发父类 Parent 的初始化而不会触发子类 Child 的初始化。
虽然只有Parent被初始化，但是Parent和Child都经过了装载验证阶段，并被加载到内存当中

# 类的结构
https://mp.weixin.qq.com/s/pekAvJY84qSefHi69d3qgw