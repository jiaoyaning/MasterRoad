import javassist.ByteArrayClassPath
import org.apache.http.util.TextUtils
import org.gradle.api.internal.file.FilteredFileTree
import com.android.build.gradle.internal.api.DefaultAndroidSourceSet

import java.nio.file.Files
import java.nio.file.Path

import javassist.ClassPool
import javassist.CtClass
import javassist.CtMethod
import javassist.bytecode.*

/**
 * 统计代码行
 */
buildscript {
    repositories {
        maven { setUrl("https://maven.aliyun.com/repository/public") }
        maven { setUrl("https://maven.aliyun.com/repository/google") }
    }
    dependencies {
        classpath "com.android.tools.build:gradle:$gradle_version"
        classpath "org.javassist:javassist:3.29.0-GA"
    }
}

def assembleTask = ["compileDebugKotlin", "compileDebugJavaWithJavac"]
String group = "statistic"

/**
 * 统计代码行
 */
task lineStatistic(group: group) {
    doLast {
        long lineSize = 0 //总行数
        def extension = project.getPlugins().getPlugin("com.android.application").getExtension()
        def sourceSets = extension.getSourceSets()
        /**
         * @see DefaultAndroidSourceSet
         */
        sourceSets.all { androidSourceSet ->
            String name = androidSourceSet.getName()
            if (name != "main") return
            //java 源文件
            FilteredFileTree javaFileTree = androidSourceSet.getJava().getSourceFiles()
            //kotlin源文件
            FilteredFileTree kotlinFileTree = androidSourceSet.getKotlin().getSourceFiles()

            /**
             * 合并源文件，其实源码中已存在文件过滤，从此再次添加是为了展示写法
             * @see FilteredFileTree#matching(PatternFilterable) -> 添加规则
             * @see PatternFilterable#getIncludes 得到现有规则，然后 allAll() 添加新规则
             */
            FileTree fileTree = (javaFileTree + kotlinFileTree).matching { includes.addAll(['**/*.java', '**/*.kt']) }

            //遍历源，进行行统计
            fileTree.each { File file ->
                List<String> lines = file.readLines().findAll { String line ->
                    String trim = line.trim()
                    return !(trim.startsWith("/") || trim.startsWith("*") || TextUtils.isBlank(trim))
                }
                lineSize += lines.size()
                println("${file.getAbsolutePath()} 行数-> ${lines.size()}")
            }
        }
        println("总代码行数: ${lineSize}")
    }
}

/**
 * 统计方法数
 */
task methodStatistic(dependsOn: assembleTask, group: group) {
    doLast {
        // 文件排查规则
        List<String> excludeArray = ['**/databinding/**', '**/BR.class',
                                     '**/R.class', '**/BuildConfig.class',
                                     '**/arouter/routes/**', '**/arouter/routes/**',
                                     '**/*_*.class', '**/rxhttp/wrapper/**']

        List<String> targetMethod = ['com.apkfuns.logutils.LogUtils.tag']

        DirectoryProperty javaDirectory = compileDebugJavaWithJavac.getDestinationDirectory()
        DirectoryProperty kotlinDirectory = compileDebugKotlin.getDestinationDirectory()

        println("kotlinDirectory : ${kotlinDirectory.class}")

        /**
         * @see FilteredFileTree
         */
        FileTree javaTree = javaDirectory.getAsFileTree().matching {
            it.include '**/*.class'
            it.excludes.addAll(excludeArray)
        }
        FileTree kotlinTree = kotlinDirectory.getAsFileTree().matching {
            include '**/*.class'
            excludes.addAll(excludeArray)
        }

        println("kotlinDirectory : ${kotlinTree.class}")
        Path javaPath = javaDirectory.getAsFile().getOrNull().toPath()
        Path kotlinPath = kotlinDirectory.getAsFile().getOrNull().toPath()

        javaTree.each { File file ->
            println(file.absolutePath)
            String qualifiedClassName = getQualifiedClassName(javaPath, file.toPath())

            ByteArrayClassPath cp = new ByteArrayClassPath(qualifiedClassName, Files.readAllBytes(file.toPath()))
            ClassPool.getDefault().appendClassPath(cp)

            CtClass ctClass = ClassPool.getDefault().getOrNull(qualifiedClassName)
            if (ctClass == null) return true
            int count = findTargetMethodUsedCountInClass(ctClass, targetMethod)
            println("  -> ${qualifiedClassName} : ${count}/${ctClass.getDeclaredMethods().length}")
            println()
            ClassPool.getDefault().removeClassPath(cp)
        }

        kotlinTree.each { File file ->
            println(file.absolutePath)
            String qualifiedClassName = getQualifiedClassName(kotlinPath, file.toPath())

            ByteArrayClassPath cp = new ByteArrayClassPath(qualifiedClassName, Files.readAllBytes(file.toPath()))
            ClassPool.getDefault().appendClassPath(cp)

            CtClass ctClass = ClassPool.getDefault().getOrNull(qualifiedClassName)
            if (ctClass == null) return true
            int count = findTargetMethodUsedCountInClass(ctClass, targetMethod)
            println("  -> ${qualifiedClassName} : ${count}/${ctClass.getDeclaredMethods().length}")
            println()
            ClassPool.getDefault().removeClassPath(cp)
        }
    }
}

static def statisticMethod(FileTree tree, Path path, List<String> targetMethod) {
    tree.each { File file ->
        println(file.absolutePath)
        String qualifiedClassName = getQualifiedClassName(path, file.toPath())
        ByteArrayClassPath cp = new ByteArrayClassPath(qualifiedClassName, Files.readAllBytes(file.toPath()))
        ClassPool.getDefault().appendClassPath(cp)
        CtClass ctClass = ClassPool.getDefault().getOrNull(qualifiedClassName)
        if (ctClass == null) return true
        int count = findTargetMethodUsedCountInClass(ctClass, targetMethod)
        println("  -> ${qualifiedClassName} : ${count}/${ctClass.getDeclaredMethods().length}")
        println()
        ClassPool.getDefault().removeClassPath(cp)
    }
}

/**
 * 获取合格可用的的类名
 */
static def getQualifiedClassName(Path classPath, Path filePath) {
    return classPath.relativize(filePath)
            .toFile().getPath()
            .replace('\\', '.')
            .replace(".class", "")
}

/**
 * 找出 Class 中使用了目标方法的方法数
 * @see InstructionPrinter 参考
 */
static def findTargetMethodUsedCountInClass(CtClass ctClass, List<String> targetMethod) {
    int methods = 0
    ctClass.getDeclaredMethods().each { CtMethod ctMethod ->
        MethodInfo info = ctMethod.getMethodInfo2()
        ConstPool pool = info.getConstPool()
        CodeAttribute code = info.getCodeAttribute()
        if (code == null) return true //跳出本轮循环

        //遍历方法体字节码
        CodeIterator iterator = code.iterator()
        while (iterator.hasNext()) {
            int pos
            try {
                pos = iterator.next()
            } catch (BadBytecode e) {
                throw new RuntimeException(e)
            }

            //读取当前位置指令
            int opcode = iterator.byteAt(pos)
            //判断该指令是否为方法调用
            if (opcode == Opcode.INVOKESTATIC || opcode == Opcode.INVOKEVIRTUAL || opcode == Opcode.INVOKESPECIAL) {
                int index = iterator.u16bitAt(pos + 1)
                String methodFullName = "${pool.getMethodrefClassName(index)}.${pool.getMethodrefName(index)}"
                boolean isUsed = targetMethod.findAll { methodFullName == it }.size() > 0
                if (isUsed) { //包含目标方法
                    methods++
                    break
                }
            }
        }
    }
    ctClass.detach() //该CtClass已经不需要了，从ClassPool中移除
    return methods
}