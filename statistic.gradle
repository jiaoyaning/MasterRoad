import com.android.build.gradle.internal.dsl.BaseAppModuleExtension
import com.android.build.gradle.internal.api.DefaultAndroidSourceSet
import javassist.CtConstructor
import org.gradle.api.internal.file.FilteredFileTree
import org.gradle.internal.Pair

import java.nio.file.Files
import java.nio.file.Path

import javassist.ByteArrayClassPath
import javassist.ClassPool
import javassist.CtClass
import javassist.CtMethod
import javassist.bytecode.*

/**
 * 统计代码行
 */
buildscript {
    repositories {
        maven { setUrl("https://maven.aliyun.com/repository/public") }
        maven { setUrl("https://maven.aliyun.com/repository/google") }
    }
    dependencies {
        classpath "com.android.tools.build:gradle:$gradle_version"
        classpath "org.javassist:javassist:3.29.0-GA"
    }
}

def assembleTask = ["compileDebugKotlin", "compileDebugJavaWithJavac"]
def group = "statistic"

// 文件排除
def exclude = ['**/databinding/**', '**/BR.class',
               '**/R.class', '**/BuildConfig.class',
               '**/arouter/routes/**', '**/arouter/routes/**',
               '**/*_*.class', '**/rxhttp/wrapper/**', '**/LiveLiterals$*']

// 目标方法 (格式要求：完整类名.方法名)
def target = ['com.apkfuns.logutils.LogUtils.tag']

/**
 * 统计代码行
 */
task lineStatistic(group: group) {
    doLast {
        long fileSize = 0 //总文件数
        long lineSize = 0 //总行数
        long targetLineSize = 0 //包含日志的行数

        //截取出目标方法
        List<String> targetMethod = target.collect { it.substring(it.lastIndexOf(".", it.lastIndexOf(".") - 1) + 1, it.length()) }

        /**
         * @see BaseAppModuleExtension <- project.extensions.getByName("android")
         * @see DefaultAndroidSourceSet <- .getSourceSets()
         */
        project.extensions.getByName("android").getSourceSets().all { androidSourceSet ->
            String name = androidSourceSet.getName()
            if (name != "main") return
            //java 源文件
            FilteredFileTree javaFileTree = androidSourceSet.getJava().getSourceFiles()
            //kotlin源文件
            FilteredFileTree kotlinFileTree = androidSourceSet.getKotlin().getSourceFiles()

            /**
             * 合并源文件，其实源码中已存在文件过滤，从此再次添加是为了展示写法
             * @see FilteredFileTree#matching(PatternFilterable) -> 添加规则
             * @see PatternFilterable#getIncludes 得到现有规则，然后 allAll() 添加新规则
             */
            FileTree fileTree = (javaFileTree + kotlinFileTree).matching { includes.addAll(['**/*.java', '**/*.kt']) }
            fileSize += fileTree.getFiles().size()
            //遍历源文件，开始行统计
            fileTree.each { File file ->
                file.readLines().eachWithIndex { String line, int index ->
                    String trimLine = line.trim()
                    if (trimLine.startsWith("/") || trimLine.startsWith("*") || trimLine.isBlank()) return true
                    targetMethod.each {
                        if (trimLine.contains(it)) {
                            targetLineSize++
//                            println("${file.absolutePath}:${++index}")
//                            println(" ${targetLineSize} -> ${trimLine}")
                        }
                    }
                    lineSize++
                }
            }
        }

        println("总文件数: ${fileSize}")
        println("行覆盖率: ${targetLineSize}/${lineSize}")
    }
}

/**
 * 统计方法数
 */
task methodStatistic(dependsOn: assembleTask, group: group) {
    doLast {
        // 源码
        def javaDirectory = compileDebugJavaWithJavac.getDestinationDirectory()
        def kotlinDirectory = compileDebugKotlin.getDestinationDirectory()
        /**
         * @see PatternFilterable 筛选规则
         * @see FilteredFileTree 文件树
         */
        def filter = { include '**/*.class'; excludes.addAll(exclude) }

        def javaTree = javaDirectory.getAsFileTree().matching(filter)
        def kotlinTree = kotlinDirectory.getAsFileTree().matching(filter)
        def javaPath = javaDirectory.getAsFile().getOrNull().toPath()
        def kotlinPath = kotlinDirectory.getAsFile().getOrNull().toPath()

        //统计java方法
        def javaRes = statisticMethod(javaTree, javaPath, target)
        //统计kotlin方法
        def kotlinRes = statisticMethod(kotlinTree, kotlinPath, target)

        println("java 方法覆盖率：${javaRes.left()}/${javaRes.right()}")
        println("kotlin 方法覆盖率：${kotlinRes.left()}/${kotlinRes.right()}")
        println("方法覆盖率：${javaRes.left() + kotlinRes.left()}/${javaRes.right() + kotlinRes.right()}")
    }
}

/**
 * 增量代码行统计
 */
task diffLineStatistic(group: group) {
    doLast {
        /**
         * https://git-scm.com/docs/git-diff
         * https://github.com/apachecn/git-doc-zh/blob/master/docs/8.md
         */
        List<String> diffFile = "git diff master statistic --name-only".execute().text.split('\n')
                .grep { //只保留 java 和 kt 文件
                    def suffix = it.substring(it.lastIndexOf(".") + 1, it.length())
                    suffix == "java"
                }

        diffFile.each { String filepath ->
            println("DiffFile -> ${filepath}")
            String diff = "git diff --no-renames master statistic -- ${filepath}".execute().text
            println("-----------------------------------------------------------------")
            println("${diff}")
            println("-----------------------------------------------------------------")
        }
    }
}

static Pair<Long, Long> statisticMethod(FileTree tree, Path classPath, List<String> target) {
    def targetUsedMethodsCount = 0
    def allMethodsCount = 0

    tree.each { File file ->
        //转成格式化的类名
        String qualifiedClassName = classPath.relativize(file.toPath())
                .toFile().getPath()
                .replace('\\', '.')
                .replace(".class", "")

        ByteArrayClassPath cp = new ByteArrayClassPath(qualifiedClassName, Files.readAllBytes(file.toPath()))
        ClassPool.getDefault().appendClassPath(cp)
        CtClass ctClass = ClassPool.getDefault().getOrNull(qualifiedClassName)
        if (ctClass == null) return true

        def statistic = findUsedCountInClass(ctClass, target)
        targetUsedMethodsCount += statistic.left().size()
        allMethodsCount += statistic.right().size()
        println("覆盖率 : ${statistic.left().size()}/${statistic.right().size()} -> ${targetUsedMethodsCount}/${allMethodsCount} \n")

        ClassPool.getDefault().removeClassPath(cp)
    }
    return new Pair<Long, Long>(targetUsedMethodsCount, allMethodsCount)
}

/**
 * 找出 Class 中使用了目标方法的方法数 (忽略了构造方法)
 * @see InstructionPrinter 参考
 *
 * @return left:使用了目标方法的方法，right:类中的全部方法
 */
static Pair<List<String>, List<String>> findUsedCountInClass(CtClass ctClass, List<String> targetMethod) {
    //使用了目标方法的方法
    def targetUsedMethods = []
    //全部方法数量
    def allMethods = []

    println("${ctClass.name} -> ")

    //构造方法
    ctClass.getConstructors().each { CtConstructor ctConstructor ->
        print("   ${ctConstructor.name}()")
        allMethods.add(ctConstructor.longName)
        if (isContainTargetMethod(ctConstructor.getMethodInfo2(), targetMethod)) {
            print("  -->*覆盖* ")
            targetUsedMethods.add(ctConstructor.longName)
        }
        println()
    }

    //全部方法
    ctClass.getDeclaredMethods().each { CtMethod ctMethod ->
        print("   ${ctMethod.name}()")
        allMethods.add(ctMethod.longName)
        if (isContainTargetMethod(ctMethod.getMethodInfo2(), targetMethod)) {
            print("  -->*覆盖* ")
            targetUsedMethods.add(ctMethod.longName)
        }
        println()
    }

    ctClass.detach() //该CtClass已经不需要了，从ClassPool中移除
    return new Pair<List<String>, List<String>>(targetUsedMethods, allMethods)
}

/**
 * 判断方法体中是否引用了目标方法
 */
static boolean isContainTargetMethod(MethodInfo info, List<String> targetMethod) {
    ConstPool pool = info.getConstPool()
    CodeAttribute code = info.getCodeAttribute()
    if (code == null) return true //跳出本轮循环

    //遍历方法体字节码
    CodeIterator iterator = code.iterator()
    while (iterator.hasNext()) {
        int pos = iterator.next()
        //读取当前位置指令
        int opcode = iterator.byteAt(pos)
        //判断该指令是否为方法调用
        if (opcode == Opcode.INVOKESTATIC || opcode == Opcode.INVOKEVIRTUAL || opcode == Opcode.INVOKESPECIAL) {
            int index = iterator.u16bitAt(pos + 1)
            //拼接出完整方法：类名+方法
            String methodFullName = "${pool.getMethodrefClassName(index)}.${pool.getMethodrefName(index)}"
            boolean isUsed = targetMethod.findAll { methodFullName == it }.size() > 0
            //包含目标方法
            if (isUsed) return true
        }
    }
    return false
}